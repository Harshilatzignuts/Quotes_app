{"ast":null,"code":"import { useState, useRef, useCallback } from 'react';\nimport { useFreshCallback } from './useFreshCallback.js';\nimport { useTimeoutWhen } from './useTimeoutWhen.js';\n\n/**\r\n * useDebounceFn\r\n * @description Powerful debounce function hook for React\r\n * @see {@link https://rooks.vercel.app/docs/useDebounceFn}\r\n */\nfunction useDebounceFn(func, delay, options = {\n  leading: false,\n  trailing: true\n}) {\n  const {\n    leading,\n    trailing,\n    maxWait\n  } = options;\n  if (!leading && !trailing) {\n    throw new Error(\"leading and trailing cannot both be false\");\n  } else if (typeof maxWait !== \"undefined\" && maxWait < delay) {\n    throw new Error(\"maxWait cannot be less than delay\");\n  }\n  const funcRef = useFreshCallback(func);\n  const [isTimeoutEnabled, setIsTimeoutEnabled] = useState(false);\n  // we use key to reset a timeout when the key changes\n  const [key, setKey] = useState(0);\n  const lastExecutionTimeRef = useRef(0);\n  const argsRef = useRef();\n  const debouncedFn = useCallback((...args) => {\n    argsRef.current = args;\n    const overrideTimeout = typeof maxWait !== \"undefined\" && lastExecutionTimeRef.current && Date.now() - lastExecutionTimeRef.current > maxWait;\n    // If the leading edge is enabled, we should call the function\n    // immediately\n    // if timeout is not enabled, we should call the function\n    if (leading) {\n      if (isTimeoutEnabled && overrideTimeout) {\n        // reset the timeout\n        setKey(prevKey => prevKey + 1);\n        lastExecutionTimeRef.current = Date.now();\n        try {\n          funcRef(...args);\n        } catch (error) {\n          console.warn(error);\n        }\n      } else if (overrideTimeout && !isTimeoutEnabled) {\n        setIsTimeoutEnabled(true);\n        lastExecutionTimeRef.current = Date.now();\n        try {\n          funcRef(...args);\n        } catch (error) {\n          console.warn(error);\n        }\n      } else if (isTimeoutEnabled && !overrideTimeout) ;else {\n        // !isTimeoutEnabled && !overrideTimeout\n        setIsTimeoutEnabled(true);\n        lastExecutionTimeRef.current = Date.now();\n        try {\n          funcRef(...args);\n        } catch (error) {\n          console.warn(error);\n        }\n      }\n    }\n    if (trailing) {\n      // trailing scenarios\n      if (isTimeoutEnabled) {\n        // reset the timeout\n        setKey(prevKey => prevKey + 1);\n      } else {\n        // set the timeout\n        setIsTimeoutEnabled(true);\n      }\n    }\n  }, [maxWait, isTimeoutEnabled, leading, trailing, funcRef]);\n  // if timeout is enabled, is trailing and maxWait is defined, we should clear the timeout\n  // and call the function\n  useTimeoutWhen(() => {\n    // noop condition but for typechecking\n    if (typeof maxWait !== \"undefined\" && trailing) {\n      if (!argsRef.current) return;\n      lastExecutionTimeRef.current = Date.now();\n      try {\n        funcRef(...argsRef.current);\n      } catch (error) {\n        console.warn(error);\n      }\n    }\n  }, maxWait !== null && maxWait !== void 0 ? maxWait : Infinity, isTimeoutEnabled && typeof maxWait !== \"undefined\" && trailing, key);\n  useTimeoutWhen(() => {\n    if (trailing) {\n      if (!argsRef.current) return;\n      lastExecutionTimeRef.current = Date.now();\n      try {\n        funcRef(...argsRef.current);\n      } catch (error) {\n        console.warn(error);\n      }\n    }\n    setIsTimeoutEnabled(false);\n  }, delay, isTimeoutEnabled && trailing, key);\n  const freshDebouncedFn = useFreshCallback(debouncedFn);\n  return [freshDebouncedFn, isTimeoutEnabled];\n}\nexport { useDebounceFn };","map":{"version":3,"names":["useState","useRef","useCallback","useFreshCallback","useTimeoutWhen","useDebounceFn","func","delay","options","leading","trailing","maxWait","Error","funcRef","isTimeoutEnabled","setIsTimeoutEnabled","key","setKey","lastExecutionTimeRef","argsRef","debouncedFn","args","current","overrideTimeout","Date","now","prevKey","error","console","warn","Infinity","freshDebouncedFn"],"sources":["/home/zt62/Desktop/Harshil_Dave/MERN_PRACTICE/client/node_modules/rooks/dist/esm/hooks/useDebounceFn.js"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\nimport { useFreshCallback } from './useFreshCallback.js';\nimport { useTimeoutWhen } from './useTimeoutWhen.js';\n\n/**\r\n * useDebounceFn\r\n * @description Powerful debounce function hook for React\r\n * @see {@link https://rooks.vercel.app/docs/useDebounceFn}\r\n */\r\nfunction useDebounceFn(func, delay, options = { leading: false, trailing: true }) {\r\n    const { leading, trailing, maxWait } = options;\r\n    if (!leading && !trailing) {\r\n        throw new Error(\"leading and trailing cannot both be false\");\r\n    }\r\n    else if (typeof maxWait !== \"undefined\" && maxWait < delay) {\r\n        throw new Error(\"maxWait cannot be less than delay\");\r\n    }\r\n    const funcRef = useFreshCallback(func);\r\n    const [isTimeoutEnabled, setIsTimeoutEnabled] = useState(false);\r\n    // we use key to reset a timeout when the key changes\r\n    const [key, setKey] = useState(0);\r\n    const lastExecutionTimeRef = useRef(0);\r\n    const argsRef = useRef();\r\n    const debouncedFn = useCallback((...args) => {\r\n        argsRef.current = args;\r\n        const overrideTimeout = typeof maxWait !== \"undefined\" &&\r\n            lastExecutionTimeRef.current &&\r\n            Date.now() - lastExecutionTimeRef.current > maxWait;\r\n        // If the leading edge is enabled, we should call the function\r\n        // immediately\r\n        // if timeout is not enabled, we should call the function\r\n        if (leading) {\r\n            if (isTimeoutEnabled && overrideTimeout) {\r\n                // reset the timeout\r\n                setKey((prevKey) => prevKey + 1);\r\n                lastExecutionTimeRef.current = Date.now();\r\n                try {\r\n                    funcRef(...args);\r\n                }\r\n                catch (error) {\r\n                    console.warn(error);\r\n                }\r\n            }\r\n            else if (overrideTimeout && !isTimeoutEnabled) {\r\n                setIsTimeoutEnabled(true);\r\n                lastExecutionTimeRef.current = Date.now();\r\n                try {\r\n                    funcRef(...args);\r\n                }\r\n                catch (error) {\r\n                    console.warn(error);\r\n                }\r\n            }\r\n            else if (isTimeoutEnabled && !overrideTimeout) ;\r\n            else {\r\n                // !isTimeoutEnabled && !overrideTimeout\r\n                setIsTimeoutEnabled(true);\r\n                lastExecutionTimeRef.current = Date.now();\r\n                try {\r\n                    funcRef(...args);\r\n                }\r\n                catch (error) {\r\n                    console.warn(error);\r\n                }\r\n            }\r\n        }\r\n        if (trailing) {\r\n            // trailing scenarios\r\n            if (isTimeoutEnabled) {\r\n                // reset the timeout\r\n                setKey((prevKey) => prevKey + 1);\r\n            }\r\n            else {\r\n                // set the timeout\r\n                setIsTimeoutEnabled(true);\r\n            }\r\n        }\r\n    }, [maxWait, isTimeoutEnabled, leading, trailing, funcRef]);\r\n    // if timeout is enabled, is trailing and maxWait is defined, we should clear the timeout\r\n    // and call the function\r\n    useTimeoutWhen(() => {\r\n        // noop condition but for typechecking\r\n        if (typeof maxWait !== \"undefined\" && trailing) {\r\n            if (!argsRef.current)\r\n                return;\r\n            lastExecutionTimeRef.current = Date.now();\r\n            try {\r\n                funcRef(...argsRef.current);\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        }\r\n    }, maxWait !== null && maxWait !== void 0 ? maxWait : Infinity, isTimeoutEnabled && typeof maxWait !== \"undefined\" && trailing, key);\r\n    useTimeoutWhen(() => {\r\n        if (trailing) {\r\n            if (!argsRef.current)\r\n                return;\r\n            lastExecutionTimeRef.current = Date.now();\r\n            try {\r\n                funcRef(...argsRef.current);\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        }\r\n        setIsTimeoutEnabled(false);\r\n    }, delay, isTimeoutEnabled && trailing, key);\r\n    const freshDebouncedFn = useFreshCallback(debouncedFn);\r\n    return [freshDebouncedFn, isTimeoutEnabled];\r\n}\n\nexport { useDebounceFn };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}