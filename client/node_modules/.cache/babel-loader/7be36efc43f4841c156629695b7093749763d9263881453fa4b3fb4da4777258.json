{"ast":null,"code":"import { useState, useCallback, useMemo } from 'react';\n\n/**\r\n * useUndoRedoState\r\n * @description Setstate but can also undo and redo\r\n * @see {@link https://rooks.vercel.app/docs/useUndoRedoState}\r\n */\nfunction isFunctionInitializer(functionToCheck) {\n  return typeof functionToCheck === \"function\";\n}\n/**\r\n * useUndoRedoState hook\r\n *\r\n * This hook manages the state with undo and redo capabilities.\r\n *\r\n * @param initialState - The initial state value\r\n * @param options - An optional object with a `maxDepth` property to limit the history and future arrays\r\n * @returns A tuple with the current state, a function to update the state, and an object with undo and redo controls\r\n *\r\n * @example\r\n * const [state, setState, controls] = useUndoRedoState(0, { maxDepth: 3 });\r\n * // state is 0\r\n * setState(1); // state is 1\r\n * controls.undo(); // state is 0\r\n * controls.redo(); // state is 1\r\n */\nfunction useUndoRedoState(initialState, options) {\n  var _a;\n  const [state, _setState] = useState(initialState);\n  const [past, setPast] = useState([]);\n  const [future, setFuture] = useState([]);\n  const maxDepth = (_a = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _a !== void 0 ? _a : 100;\n  const undo = useCallback(() => {\n    setPast(pastStates => {\n      const newPast = [...pastStates];\n      const previousState = newPast.pop();\n      if (typeof previousState !== \"undefined\") {\n        setFuture(futureStates => [state, ...futureStates]);\n        _setState(previousState);\n      }\n      return newPast;\n    });\n  }, [state]);\n  const redo = useCallback(() => {\n    setFuture(futureStates => {\n      const newFuture = [...futureStates];\n      const nextState = newFuture.shift();\n      if (typeof nextState !== \"undefined\") {\n        setPast(pastStates => [...pastStates, state]);\n        _setState(nextState);\n      }\n      return newFuture;\n    });\n  }, [state]);\n  const canUndo = useCallback(() => past.length > 0, [past]);\n  const canRedo = useCallback(() => future.length > 0, [future]);\n  const isUndoPossible = useMemo(() => past.length > 0, [past]);\n  const isRedoPossible = useMemo(() => future.length > 0, [future]);\n  const setState = useCallback(value => {\n    _setState(prevState => {\n      const nextState = isFunctionInitializer(value) ? value(prevState) : value;\n      setPast(pastStates => {\n        const newPast = [...pastStates, prevState];\n        if (newPast.length > maxDepth) {\n          newPast.shift();\n        }\n        return newPast;\n      });\n      setFuture([]);\n      return nextState;\n    });\n  }, [maxDepth]);\n  const clearUndoStack = useCallback(() => {\n    setPast([]);\n  }, []);\n  const clearRedoStack = useCallback(() => {\n    setFuture([]);\n  }, []);\n  const clearAll = useCallback(() => {\n    setPast([]);\n    setFuture([]);\n  }, []);\n  const controls = useMemo(() => {\n    return {\n      undo,\n      redo,\n      canUndo,\n      canRedo,\n      clearUndoStack,\n      clearRedoStack,\n      clearAll,\n      isUndoPossible,\n      isRedoPossible\n    };\n  }, [undo, redo, canUndo, canRedo, clearUndoStack, clearRedoStack, clearAll, isUndoPossible, isRedoPossible]);\n  return [state, setState, controls];\n}\nexport { useUndoRedoState };","map":{"version":3,"names":["useState","useCallback","useMemo","isFunctionInitializer","functionToCheck","useUndoRedoState","initialState","options","_a","state","_setState","past","setPast","future","setFuture","maxDepth","undo","pastStates","newPast","previousState","pop","futureStates","redo","newFuture","nextState","shift","canUndo","length","canRedo","isUndoPossible","isRedoPossible","setState","value","prevState","clearUndoStack","clearRedoStack","clearAll","controls"],"sources":["/home/zt62/Desktop/Harshil_Dave/MERN_PRACTICE/client/node_modules/rooks/dist/esm/hooks/useUndoRedoState.js"],"sourcesContent":["import { useState, useCallback, useMemo } from 'react';\n\n/**\r\n * useUndoRedoState\r\n * @description Setstate but can also undo and redo\r\n * @see {@link https://rooks.vercel.app/docs/useUndoRedoState}\r\n */\r\nfunction isFunctionInitializer(functionToCheck) {\r\n    return typeof functionToCheck === \"function\";\r\n}\r\n/**\r\n * useUndoRedoState hook\r\n *\r\n * This hook manages the state with undo and redo capabilities.\r\n *\r\n * @param initialState - The initial state value\r\n * @param options - An optional object with a `maxDepth` property to limit the history and future arrays\r\n * @returns A tuple with the current state, a function to update the state, and an object with undo and redo controls\r\n *\r\n * @example\r\n * const [state, setState, controls] = useUndoRedoState(0, { maxDepth: 3 });\r\n * // state is 0\r\n * setState(1); // state is 1\r\n * controls.undo(); // state is 0\r\n * controls.redo(); // state is 1\r\n */\r\nfunction useUndoRedoState(initialState, options) {\r\n    var _a;\r\n    const [state, _setState] = useState(initialState);\r\n    const [past, setPast] = useState([]);\r\n    const [future, setFuture] = useState([]);\r\n    const maxDepth = (_a = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _a !== void 0 ? _a : 100;\r\n    const undo = useCallback(() => {\r\n        setPast((pastStates) => {\r\n            const newPast = [...pastStates];\r\n            const previousState = newPast.pop();\r\n            if (typeof previousState !== \"undefined\") {\r\n                setFuture((futureStates) => [state, ...futureStates]);\r\n                _setState(previousState);\r\n            }\r\n            return newPast;\r\n        });\r\n    }, [state]);\r\n    const redo = useCallback(() => {\r\n        setFuture((futureStates) => {\r\n            const newFuture = [...futureStates];\r\n            const nextState = newFuture.shift();\r\n            if (typeof nextState !== \"undefined\") {\r\n                setPast((pastStates) => [...pastStates, state]);\r\n                _setState(nextState);\r\n            }\r\n            return newFuture;\r\n        });\r\n    }, [state]);\r\n    const canUndo = useCallback(() => past.length > 0, [past]);\r\n    const canRedo = useCallback(() => future.length > 0, [future]);\r\n    const isUndoPossible = useMemo(() => past.length > 0, [past]);\r\n    const isRedoPossible = useMemo(() => future.length > 0, [future]);\r\n    const setState = useCallback((value) => {\r\n        _setState((prevState) => {\r\n            const nextState = isFunctionInitializer(value)\r\n                ? value(prevState)\r\n                : value;\r\n            setPast((pastStates) => {\r\n                const newPast = [...pastStates, prevState];\r\n                if (newPast.length > maxDepth) {\r\n                    newPast.shift();\r\n                }\r\n                return newPast;\r\n            });\r\n            setFuture([]);\r\n            return nextState;\r\n        });\r\n    }, [maxDepth]);\r\n    const clearUndoStack = useCallback(() => {\r\n        setPast([]);\r\n    }, []);\r\n    const clearRedoStack = useCallback(() => {\r\n        setFuture([]);\r\n    }, []);\r\n    const clearAll = useCallback(() => {\r\n        setPast([]);\r\n        setFuture([]);\r\n    }, []);\r\n    const controls = useMemo(() => {\r\n        return {\r\n            undo,\r\n            redo,\r\n            canUndo,\r\n            canRedo,\r\n            clearUndoStack,\r\n            clearRedoStack,\r\n            clearAll,\r\n            isUndoPossible,\r\n            isRedoPossible,\r\n        };\r\n    }, [\r\n        undo,\r\n        redo,\r\n        canUndo,\r\n        canRedo,\r\n        clearUndoStack,\r\n        clearRedoStack,\r\n        clearAll,\r\n        isUndoPossible,\r\n        isRedoPossible,\r\n    ]);\r\n    return [state, setState, controls];\r\n}\n\nexport { useUndoRedoState };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}